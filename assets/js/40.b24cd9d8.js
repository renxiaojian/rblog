(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{455:function(e,t,s){"use strict";s.r(t);var a=s(21),i=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"_1-node-js-的运行机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-node-js-的运行机制"}},[e._v("#")]),e._v(" 1 Node.js 的运行机制")]),e._v(" "),s("ul",[s("li",[e._v("V8 引擎解析 "),s("code",[e._v("JavaScript")]),e._v(" 脚本")]),e._v(" "),s("li",[e._v("解析后的代码，调用 Node API")]),e._v(" "),s("li",[e._v("libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个 Event Loop（事件循环），以异步的方式将任务的执行结果返回给 V8 引擎。")]),e._v(" "),s("li",[e._v("V8 引擎再将结果返回给用户。")])]),e._v(" "),s("p",[e._v("实际上node中的事件循环存在于libuv引擎中。")]),e._v(" "),s("h2",{attrs:{id:"_2-六个阶段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-六个阶段"}},[e._v("#")]),e._v(" 2 六个阶段")]),e._v(" "),s("ol",[s("li",[s("strong",[e._v("timers")]),e._v("：setTimeout()和setInterval()调度的回调函数，由这两个函数启动的回调函数")]),e._v(" "),s("li",[s("strong",[e._v("pending callbacks")]),e._v("：本阶段执行某些系统操作的回调函数")]),e._v(" "),s("li",[s("strong",[e._v("idle、prepare")]),e._v("：仅系统内部使用只需要知道有这2个阶段就可以")]),e._v(" "),s("li",[s("strong",[e._v("poll")]),e._v("：检索I/O事件，执行与I/O相关的回调，其他情况NodeJs将在适当时在此阻塞")]),e._v(" "),s("li",[s("strong",[e._v("check")]),e._v("：setImmediate()回调函数在这里执行。setImmediate并不是立马执行而是当事件循环poll阶段中没有新的事件处理时就执行该部分\n6."),s("strong",[e._v("close callbacks")]),e._v("：执行一些关闭的回调函数。如socket.on('close')")])]),e._v(" "),s("h2",{attrs:{id:"_3-poll阶段详解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-poll阶段详解"}},[e._v("#")]),e._v(" 3 poll阶段详解")]),e._v(" "),s("p",[e._v("循环首先进入的是 "),s("code",[e._v("poll")]),e._v(" 阶段，执行逻辑如下：")]),e._v(" "),s("p",[e._v("查看"),s("code",[e._v("poll")]),e._v("队列中是否有事件")]),e._v(" "),s("p",[e._v("有，任务按先进先出的顺序依次执行回调；")]),e._v(" "),s("p",[e._v("无，")]),e._v(" "),s("ol",[s("li",[e._v("如果有 setImmediate 回调需要执行，就进入 "),s("code",[e._v("check")]),e._v(" 阶段执行这些回调；检查是否有到期的 "),s("code",[e._v("timer")]),e._v(" ，如果有就把这些到期的 timer 的回调按照调用顺序放入到 timer 队列中，之后循环会进入timer阶段执行队列中的回调 。"),s("em",[e._v("（这两者顺序不固定）")])]),e._v(" "),s("li",[e._v("如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调")])]),e._v(" "),s("p",[e._v("注意：poll阶段在执行poll queue中的回调时实际上不会无限的执行下去。有两种情况poll阶段会终止执行poll queue中的下一个回调：")]),e._v(" "),s("ol",[s("li",[e._v("所有回调执行完毕。")]),e._v(" "),s("li",[e._v("执行数超过了node的限制。")])]),e._v(" "),s("h2",{attrs:{id:"_4-settimeout-和-setimmediate"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-settimeout-和-setimmediate"}},[e._v("#")]),e._v(" 4 setTimeout 和 setImmediate")]),e._v(" "),s("p",[e._v("二者非常相似，区别主要在于调用时机不同。")]),e._v(" "),s("ul",[s("li",[e._v("setImmediate 设计在 poll 阶段完成时执行，即 check 阶段；")]),e._v(" "),s("li",[e._v("setTimeout 设计在 poll 阶段为空闲时，且设定时间到达后执行，但它在 timer 阶段执行")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("setTimeout(function timeout () {\n  console.log('timeout');\n},0);\nsetImmediate(function immediate () {\n  console.log('immediate');\n});\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br")])]),s("ul",[s("li",[e._v("对于以上代码来说，setTimeout 可能执行在前，也可能执行在后。")]),e._v(" "),s("li",[e._v("首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的\n进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调")]),e._v(" "),s("li",[e._v("如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const fs = require('fs')\nfs.readFile(__filename, () => {\n    setTimeout(() => {\n        console.log('timeout');\n    }, 0)\n    setImmediate(() => {\n        console.log('immediate')\n    })\n})\n// immediate\n// timeout\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br")])]),s("p",[e._v("二者在异步 i/o callback 内部调用时，总是先执行 setImmediate，再执行 setTimeout")]),e._v(" "),s("h2",{attrs:{id:"_5-process-nexttick"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-process-nexttick"}},[e._v("#")]),e._v(" 5 process.nextTick")]),e._v(" "),s("p",[e._v("node中存在着一个特殊的队列，即nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，但是这些事件却会在"),s("strong",[e._v("每一个阶段执行完毕准备进入下一个阶段时优先执行")]),e._v("。当事件循环准备进入下一个阶段之前，会先检查nextTick queue中是否有任务，如果有，那么会先清空这个队列。与执行poll queue中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用process.nextTick()方法会导致node进入一个死循环，直到内存泄漏。")])])}),[],!1,null,null,null);t.default=i.exports}}]);