---
title: Node 中的 Event Loop
date: 2021-07-01 11:36:10
permalink: /pages/4f06ba/
categories:
  - 日积月累
  - 事件循环机制
tags:
  - 
---

## 1 Node.js 的运行机制

- V8 引擎解析 `JavaScript` 脚本
- 解析后的代码，调用 Node API
- libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个 Event Loop（事件循环），以异步的方式将任务的执行结果返回给 V8 引擎。
- V8 引擎再将结果返回给用户。

实际上node中的事件循环存在于libuv引擎中。

## 2 六个阶段

1. **timers**：setTimeout()和setInterval()调度的回调函数，由这两个函数启动的回调函数
2. **pending callbacks**：本阶段执行某些系统操作的回调函数
3. **idle、prepare**：仅系统内部使用只需要知道有这2个阶段就可以
4. **poll**：检索I/O事件，执行与I/O相关的回调，其他情况NodeJs将在适当时在此阻塞
5. **check**：setImmediate()回调函数在这里执行。setImmediate并不是立马执行而是当事件循环poll阶段中没有新的事件处理时就执行该部分
6.**close callbacks**：执行一些关闭的回调函数。如socket.on('close')

## 3 poll阶段详解

循环首先进入的是 `poll` 阶段，执行逻辑如下：

查看`poll`队列中是否有事件

有，任务按先进先出的顺序依次执行回调；

无，
1. 如果有 setImmediate 回调需要执行，就进入 `check` 阶段执行这些回调；检查是否有到期的 `timer` ，如果有就把这些到期的 timer 的回调按照调用顺序放入到 timer 队列中，之后循环会进入timer阶段执行队列中的回调 。*（这两者顺序不固定）*
2. 如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调

注意：poll阶段在执行poll queue中的回调时实际上不会无限的执行下去。有两种情况poll阶段会终止执行poll queue中的下一个回调：
1. 所有回调执行完毕。
2. 执行数超过了node的限制。

## 4 setTimeout 和 setImmediate

二者非常相似，区别主要在于调用时机不同。

- setImmediate 设计在 poll 阶段完成时执行，即 check 阶段；
- setTimeout 设计在 poll 阶段为空闲时，且设定时间到达后执行，但它在 timer 阶段执行

```
setTimeout(function timeout () {
  console.log('timeout');
},0);
setImmediate(function immediate () {
  console.log('immediate');
});
```

- 对于以上代码来说，setTimeout 可能执行在前，也可能执行在后。
- 首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的
进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调
- 如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了

```
const fs = require('fs')
fs.readFile(__filename, () => {
    setTimeout(() => {
        console.log('timeout');
    }, 0)
    setImmediate(() => {
        console.log('immediate')
    })
})
// immediate
// timeout
```

二者在异步 i/o callback 内部调用时，总是先执行 setImmediate，再执行 setTimeout

## 5 process.nextTick

node中存在着一个特殊的队列，即nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，但是这些事件却会在**每一个阶段执行完毕准备进入下一个阶段时优先执行**。当事件循环准备进入下一个阶段之前，会先检查nextTick queue中是否有任务，如果有，那么会先清空这个队列。与执行poll queue中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用process.nextTick()方法会导致node进入一个死循环，直到内存泄漏。