---
title: 实现二叉树先序、中序和后序遍历
date: 2021-07-09 16:07:49
permalink: /pages/dfd35c/
categories:
  - 更多
  - 算法题
tags:
  - 
---

## 1 题目

分别按照二叉树先序，中序和后序打印所有的节点。

**示例**

```
输入：{1,2,3}
返回值：[[1,2,3],[2,1,3],[2,3,1]]
```

## 2 题解

### 2.1 递归

```
function threeOrders (root) {
    const preArr = [] 
    const midArr = [] 
    const afterArr = []
    // 先序遍历：根、左、右
    const preOrder = function (root) {
        if(!root) return null
        if(root.val) preArr.push(root.val)
        if(root.left) preOrder(root.left)
        if(root.right) preOrder(root.right)
    } 
    // 中序遍历 ： 左 根 右
    const midOrder = function (root) {
        if(!root) return null
        if(root.left) midOrder(root.left)
        if(root.val) midArr.push(root.val)
        if(root.right) midOrder(root.right)
    } 
    // 后序遍历：左右根
    const afterOrder = function (root) {
        if(!root) return null
        if(root.left) afterOrder(root.left)
        if(root.right) afterOrder(root.right)
        if(root.val) afterArr.push(root.val)
    }
    preOrder(root)
    midOrder(root)
    afterOrder(root)
    return [preArr,midArr,afterArr]
}
```

### 2.2 非递归

```
function threeOrders (root) {
    const preOrder = function (root){
        let res = []
        let stack = []
        if (root!== null) {
            stack.push(root);
            while (stack.length !==0 ) {
                root = stack.pop()
                res.push(root.val)
                if (root.right) stack.push(root.right)  // 先压右
                if (root.left) stack.push(root.left)    // 再压左
            }
        }
        return res
    }
    const midOrder = function (root) {
        let res = []
        let stack = []
        if (root!== null) {
            while (root !== null || stack.length !==0 ) {
                if(root !== null) {
                    stack.push(root)
                    root = root.left
                } else {
                    root = stack.pop()
                    res.push(root.val)
                    root = root.right
                }
            }
        }
        return res
    }
    const afterOrder = function (root) {
        let res = []
        let stack1 = []
        let stack2 = []
        if (root!== null) {
            stack1.push(root);
            while (stack1.length !== 0) {
                root = stack1.pop();
                stack2.push(root);
                if (root.left) stack1.push(root.left);
                if (root.right) stack1.push(root.right);
            }
            while (stack2.length !== 0) {
                res.push(stack2.pop().val);
            }
        }
        return res
    }
    return [preOrder(root),midOrder(root),afterOrder(root)]
}
```

## 3 生成二叉树

**节点类**

```
class Node {
    constructor(key){
        this.key = key
        this.right = null
        this.left = null
    }
}
```

根据节点类构建二叉树结构

```
class BinaryTree {
    constructor(){
        this.root = null    // 根节点
    }
     // 插入，插入的是一个节点，所以应该先把值生成节点(包括节点值，左指针，右指针)
    insert(key){
        const newNode = new Node(key)
        // 如果根节点为空，则新节点作为根节点，否则在根节点下进行插入
        if(this.root === null) {
            this.root = newNode
        }
        this.insertNode(this.root,newNode)
    }
    // 有根节点的情况下插入值
    insertNode(root,newNode) {
        if(newNode.key < root.key){
            // 进入左子树
            if(root.left === null){ // 左子树为空
                root.left = newNode
            } else {    // 左子树已存在
                this.insertNode(root.left,newNode)
            }
        } else if(newNode.key > root.key){
             // 进入右子树
            if (root.right === null) {
                // 右子树为空
                root.right = newNode;
            } else {
                // 右子树已存在
                this.insertNode(root.right, newNode);
            }
        }
    }
}
```