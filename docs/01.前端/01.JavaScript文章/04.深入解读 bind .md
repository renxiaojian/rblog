---
title: 深入解读 bind 
date: 2021-06-22 16:09:32
permalink: /pages/b95cf1/
categories:
  - 前端
  - JavaScript文章
tags:
  - 
---

## 结论1

```
console.log(typeof Function.prototype.bind); // function
console.log(typeof Function.prototype.bind());  // function
console.log(Function.prototype.bind.name);  // bind
console.log(Function.prototype.bind().name);  // bound
```

1. `bind` 是 `Function` 原型链中 `Function.prototype` 的一个属性，每个函数都可以调用它
2. `bind` 本身是一个名为 `bind` 函数，返回值也是函数，函数名是 `bound `

## 结论2

```
var obj = {
    name: 'Jack',
};
function original(a, b){
    console.log(this.name);
    console.log([a, b]);
    return false;
}
var bound = original.bind(obj, 1);
var boundResult = bound(2); // 'Jack', [1, 2]
console.log(boundResult); // false
console.log(original.bind.name); // 'bind'
console.log(original.bind.length); // 1
console.log(original.bind().length); // 2 返回original函数的形参个数
console.log(bound.name); // 'bound original'
console.log((function(){}).bind().name); // 'bound '
console.log((function(){}).bind().length); // 0
```
1. 调用 `bind` 的函数中的 `this` 指向 `bind()` 函数的第一个参数
2. 传给 `bind` 的其他参数接受处理了，`bind()` 之后返回的函数的参数也接受处理了，也就是说**合并处理**了
3. `bind()` 后的 `name` 为 `bound + 空格 + 调用bind的函数名`。匿名函数则是 `bound + 空格`
4. `bind` 后的返回值函数，执行后返回值是原函数的返回值
5. `bind` 函数形参（即函数的`length`）是 `1`。`bind` 后返回的 `bound` 函数形参不定，更具绑定的函数原函数形参个数确定

### 实现一个简版的 `bindFn`

```
Function.prototype.bindFn = function bind(thisArg){
    if(typeof this !== 'function'){
        throw new TypeError(this + 'must be a function')
    }
    var self = this;    // 存储函数本身
    var args = [].slice.call(arguments,1);  // 去除thisArg的第一个参数，转成数组
    var bound = function(){
        var bounds = [].slice.call(arguments)   // bound 返回的函数参数转成数组
        return self.apply(self,args.concat(boundArgs))  // apply修改指向，合并参数
    }
    return bound
}
```

## 结论3

函数是可以用 `new` 来实例化的。那么 `bind()` 返回值函数会是什么表现呢。

```
var obj = { name :'Jack'}
function original(a, b){
    console.log('this',this);   // original {}
    console.log('typeof this', typeof this)
    this.name = b;
    console.log('name', this.name)
    console.log('this', this)
    console.log([a, b])
}
var bound = original.bind(obj, 1)
var newBoundResult = new bound(2)
console.log('newBoundResult', newBoundResult)
```
1. `bind` 原先指向 `obj` 的失效了，其他参数有效
2.  `new bound` 的返回值是以 `original` 原函数构造器生成的新对象。 `original` 原函数的 `this` 指向的就是这个对象

**所以相当于 `new` 调用时，bind的返回值函数 `bound` 内部要模拟实现new实现的操作。**

```
Function.prototype.bind = Function.prototype.bind || function bind(thisArg){
    if(typeof this !== 'function'){
        throw new TypeError(this + ' must be a function');
    }
    var self = this;
    var args = [].slice.call(arguments, 1);
    var bound = function(){
        var boundArgs = [].slice.call(arguments);
        var finalArgs = args.concat(boundArgs);
         // new 调用时，其实this instanceof bound判断也不是很准确。es6 new.target就是解决这一问题的。
        if(this instanceof bound){
            // self可能是ES6的箭头函数，没有prototype，所以就没必要再指向做prototype操作。
            if(self.prototype){
                function Empty(){}
                Empty.prototype = self.prototype;
                bound.prototype = new Empty();
            }
            var result = self.apply(this, finalArgs);
            var isObject = typeof result === 'object' && result !== null;
            var isFunction = typeof result === 'function';
            if(isObject || isFunction){
                return result;
            }
            return this;
        }
        else{
            return self.apply(thisArg, finalArgs);
        }
    };
    return bound;
}
```

## 小结

```
const isComplexDataType = obj => (typeof obj === 'Object' || typeof obj === 'function') && obj !== null

const selfBind = function (bindTarget,...args1) {
    if(typeof this !== 'function') throw new TypeError('Bind must be called on a function')
    const originFunc = this
    const boundFunc = function (...args2) {
        // 使用new关键字调用返回新对象
        if(new.target){
            let res = originFunc.call(this,...args1,...args2)
            if(isComplexDataType(res)) return res
            return this
        } else {
            originFunc.call(bindTarget,...args1,...args2)
        }
    }
    if(originFcun.prototypr){
        boundFunc.prototypr = originFcun.prototypr
    }
    // 定义绑定后函数的长度和名字
    const desc = Object.getOwnPropertyDescriptors(originFunc)
    Object,defineProperties(boundFunc,{
        length:desc.length,
        name: Object.assign(desc.name,{
            value: `bound ${desc.name.value}`
        })
    })
    return boundFunc
}
```

实现函数的 bind 方法核心是利用 call 绑定 this 指向，同时考虑了一些其他情况

- bind 返回的函数被 new 调用作为构造函数时，绑定的值会失效并且改为 new 指定的对象
- 定义了绑定后函数的 length 属性和 name 属性（不可枚举属性）
- 绑定后函数的 prototype 需指向原函数的 prototype