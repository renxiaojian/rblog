---
title: 作用域和闭包
date: 2021-06-24 10:20:16
permalink: /pages/28a0f3/
categories:
  - 前端
  - JavaScript文章
tags:
  - 闭包
  - 作用域
---

**闭包是一个可以访问外部作用域的函数，即使这个外部作用域已经执行结束**

## 1 作用域

作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和周期性

### 1.1 全局作用域

任何地方都能访问到的对象拥有全局作用域

1. 函数外定义的变量拥有全局作用域

```
var n = 2
function fn(){
    var a = 1
    return a
}
console.log(fn())   // 1
console.log(n)   // 2
console.log(a)   // 报错 error
```

2. 未定义直接赋值的变量自动声明为拥有全局作用域

```
var n = 2
function fn(){
    a = 1
    return a
}
console.log(fn())   // 1
console.log(n)   // 2
console.log(a)   // 1
```

3. `window` 对象拥有全局作用域

### 1.2 局部作用域

局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部，所以局部作用域也可称函数作用域

```
var n = 2
function fn(){
    var a = 1
    return a
}
console.log(fn())   // 1
console.log(n)   // 2
console.log(a)   // 报错 error
```

a在函数内部声明并赋值，拥有局部作用域，只能在函数fn内部使用，在fn外部访问不到报错。这就是局部作用域的特性，外部无法访问内部，但是内部可以访问外部。

- 内部函数可以访问外部函数中定义的变量和形参，即使外部函数已经执行完毕。

```
(function autorun(p){
    let x = 1;
    setTimeout(function log(){
      console.log(x); //1
      console.log(p); //10
    }, 10000);
})(10);
```

### 1.3 ES6块级作用域

```
function f1() {
  let n = 5;
  if (true) {
    let n = 10;
  }
  console.log(n); // 5
}
```
1. 外层代码块不受内层代码块的影响。内层作用域可以定义外层作用域的同名变量。

```
{{{{
  {let insane = 'Hello World'}
  console.log(insane); // 报错
}}}};
```
2. ES6 允许块级作用域的任意嵌套。每一层都是一个单独的作用域。

## 2 作用域链

1. 当执行函数时，总是先从函数内部找寻局部变量
2. 如果内部找不到（函数的局部作用域没有），则会向创建函数的作用域（声明函数的作用域）寻找，依次向上

```
var a = 1
function fn(){
    var a = 10;
    function fn1(){
        var a = 20
        console.log(a); //20
    }
    function fn2(){
        console.log(a); // 10
    }
    fn1();
    fn2();
}
fn()
console.log(a); // 1
```

## 3 闭包

### 3.1 概念

1. 红宝书(p178)上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数。
2. MDN 对闭包的定义为：闭包是指那些能够访问自由变量的函数。

### 3.2 闭包的原理

函数执行分成两个阶段(预编译阶段和执行阶段)。

- 在预编译阶段，如果发现内部函数使用了外部函数的变量，则会在内存中创建一个“闭包”对象并保存对应变量值，如果已存在“闭包”，则只需要增加对应属性值即可。
- 执行完后，函数执行上下文会被销毁，函数对“闭包”对象的引用也会被销毁，但其内部函数还持用该“闭包”的引用，所以内部函数可以继续使用“外部函数”中的变量。
  
利用了函数作用域链的特性，一个函数内部定义的函数会将包含外部函数的活动对象添加到它的作用域链中，函数执行完毕，其执行作用域链销毁，但因内部函数的作用域链仍然在引用这个活动对象，所以其活动对象不会被销毁，直到内部函数被烧毁后才被销毁

### 3.3 闭包的特性

1. 函数嵌套函数。
2. 函数内部可以引用外部的参数和变量。
3. 参数和变量不会被垃圾回收机制回收。

### 3.4 闭包的优缺点

优点：
- 可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用
- 避免全局变量的污染。
- 把变量存到独立的作用域，作为私有成员存在
缺点：
- 对内存消耗有负面影响。因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以使用不当会导致内存泄漏
- 对处理速度具有负面影响。闭包的层级决定了引用的外部变量在查找时经过的作用域链长度

### 3.5 闭包函数的作用

#### 3.5.1 匿名执行函数

```
var datamodel =[1,2,3];   
(function(dm){   
   console.log(dm)        
})(datamodel);
```
上诉代码中创建了一个匿名函数，并立即执行，由于外部无法引用它的内部变量，因此在执行完后很快就会被释放，关键是这种机制不会污染全局对象。

#### 3.5.2 缓存

如果我们有一个处理过程很耗时的函数对象，每次调用都需要花费很长时间，那么我们就会将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因此它不会释放外部的引用，从而函数内部的值可以得到保留。

#### 3.5.3 实现封装

在函数外部是无法访问其内部变量的，但可以通过闭包的形式来访问。

```
var person = function(){   
    //变量作用域为函数内部，外部无法访问   
    var name = "default";      
        
    return {   
       getName : function(){   
           return name;   
       },   
       setName : function(newName){   
           name = newName;   
       }   
    }   
}();
console.log(person.name); //直接访问，结果为undefined   
console.log(person.getName());   // default
person.setName("abruzzi");   
console.log(person.getName());  // abruzzi
```

#### 3.5.4 实现面向对象的对象

通过闭包可以模拟出类的模板机制，这样不同的对象（类的实例）拥有独立的成员及状态，互不干涉。
```
function Person(){   
    var name = "default";      
        
    return {   
       getName : function(){   
           return name;   
       },   
       setName : function(newName){   
           name = newName;   
       }   
    }   
}; 
```