---
title: 深入解读 call 和 apply 
date: 2021-06-17 13:55:08
permalink: /pages/3b8cde/
categories:
  - 前端
  - JavaScript文章
tags:
  - call  
  - apply
---

## 1 call 和 apply 的相同点

1. 简单的讲：两个方法的第一个参数是代表函数体内`this`的指向

2. 严格的讲：第一个参数指运行时指定的 `this`。而且，`this` 可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 `null` 或 `undefined` 时会自动替换为指向全局对象，原始值会被包装。严格模式下，函数的this值就是call和apply的第一个参数

```
// 例子1：浏览器环境 非严格模式下
var doSth = function(a, b){
    console.log(this);
    console.log([a, b]);
}
doSth.apply(null, [1, 2]); // this是window  // [1, 2]
doSth.apply(0, [1, 2]); // this 是 Number(0) // [1, 2]
doSth.apply(true); // this 是 Boolean(true) // [undefined, undefined]
doSth.call(undefined, 1, 2); // this 是 window // [1, 2]
doSth.call('0', 1, {a: 1}); // this 是 String('0') // [1, {a: 1}]
```

```
// 例子2：浏览器环境 严格模式下
'use strict';
var doSth2 = function(a, b){
    console.log(this);
    console.log([a, b]);
}
doSth2.call(0, 1, 2); // this 是 0 // [1, 2]
doSth2.apply('1'); // this 是 '1' // [undefined, undefined]
doSth2.apply(null, [1, 2]); // this 是 null // [1, 2]
```

## 2 call 和 apply 的不同点

`call` 参数不固定，第二个往后参数依次传入

`apply` 参数就两个，第二个参数为集合，这个集合可以为数组，也可以为类数组

## 3 call 和 apply 的用途

### 3.1 改变 this 的指向

```
const obj1 = { name : 'ming' } 
const obj2 = { name : 'hong' }
window.name = 'window'
const getName = function(){
  console.log(this.name)
}

getName()   // window
getName.call(obj1)  // ming
getName.call(obj2)  // hong
```

### 3.2 借用其它对象的方法

#### 3.2.1 借用构造函数实现继承

```
const fatherFunc = function(name){
  this.name = name
}
fatherFunc.prototype.say = function(){
  console.log('My name is ',this.name)
}
const sonFunc = function(){
  fatherFunc.apply(this,arguments)
}
sonFunc.prototype.getName = function(){
  return this.name
}
const son = new sonFunc('剑')
son.getName()
```

#### 3.2.2 借用内置对象

1. 合并两个数组 

```
const arr1 = [1,2,3]
const arr2 = [4,5,6]
Array.prototype.push.apply(arr1,arr2)
arr1:
// [1,2,3,4,5,6]
```
2. 获取数组中的最大值和最小值

```
var numbers = [5, 458 , 120 , -215 ]
Math.max.apply(Math, numbers)
```
3. 验证是否是数组

```
// 方法1
function isArray(obj){ 
  return Object.prototype.toString.call(obj) === '[object Array]';
}
// 方法2
var toStr = Function.prototype.call.bind(Object.prototype.toString);
function isArray(obj){ 
    return toStr(obj) === '[object Array]';
}
```
4. 类数组转成数组

```
var arr = [].slice.call(arguments)；

ES6:
let arr = Array.from(arguments);
let arr = [...arguments];
```

## 4 call 模拟实现过程

```
var value = 1;
var foo = {
    value: 1
};

function bar() {
    console.log(this.value);
}

bar.call(foo); // 1
```

call()主要有以下两点：

1. 改变 `this` 的指向
2. 函数 `bar` 执行了

### 4.1 模拟实现第一步

在调用call()的时候把函数 bar()添加到foo()对象中，即如下
```
var foo = {
    value: 1,
    bar: function() {
        console.log(this.value);
    }
};

foo.bar(); // 1
```
这个改动就可以实现：改变了this的指向并且执行了函数bar。foo额外添加了一个属性,用 delete 删掉就好了。

- 将函数设置为对象的属性
- 执行函数
- 删除函数

第一版本如下：
```
Function.prototype.call2 = function(context){
  context.fn = this
  context.fn()
  delete context.fn
}
```

### 4.2 模拟实现第二步

第一版有个问题，函数不能接受参数，所以我们可以从 arguments中获取参数，取出第二个到最后一个参数放到数组中，为什么要抛弃第一个参数呢，因为第一个参数是 this。

类数组转成数组，使用ES3的方案
```
var args = [];
for(var i = 1, len = arguments.length; i < len; i++) {
    args.push('arguments[' + i + ']');
}
```

第二版本如下：

```
Function.prototype.call2 = function(context) {
    context.fn = this;
    var args = [];
    for(var i = 1, len = arguments.length; i < len; i++) {
        args.push('arguments[' + i + ']');
    }
    eval('context.fn(' + args +')');
    delete context.fn;
}
```

### 4.3 模拟实现第三步

1. `this` 参数可以传 `null` 或者 `undefined`，此时 this 指向 window；`this` 参数可以传基本类型数据，原生的 `call` 会自动用 `Object()` 转换
2. 函数是可以有返回值的

```
Function.prototype.call2 = function (context) {
    context = context ? Object(context) : window; // 实现细节 1
    context.fn = this;

    var args = [];
    for(var i = 1, len = arguments.length; i < len; i++) {
        args.push('arguments[' + i + ']');
    }

    var result = eval('context.fn(' + args +')');

    delete context.fn
    return result; // 实现细节 2
}
```

## 5 call 的模拟实现

#### ES3

```
Function.prototype.call = function (context) {
    context = context ? Object(context) : window; 
    context.fn = this;

    var args = [];
    for(var i = 1, len = arguments.length; i < len; i++) {
        args.push('arguments[' + i + ']');
    }
    var result = eval('context.fn(' + args +')');

    delete context.fn
    return result;
}
```

#### ES6

```
Function.prototype.call = function (context) {
  context = context ? Object(context) : window; 
  context.fn = this;

  let args = [...arguments].slice(1);
  let result = context.fn(...args);

  delete context.fn
  return result;
}
```

## 6 apply 的模拟实现

#### ES3

```
Function.prototype.apply = function (context, arr) {
    context = context ? Object(context) : window; 
    context.fn = this;

    var result;
    // 判断是否存在第二个参数
    if (!arr) {
        result = context.fn();
    } else {
        var args = [];
        for (var i = 0, len = arr.length; i < len; i++) {
            args.push('arr[' + i + ']');
        }
        result = eval('context.fn(' + args + ')');
    }

    delete context.fn
    return result;
}
```

#### ES6

```
Function.prototype.apply = function (context, arr) {
    context = context ? Object(context) : window; 
    context.fn = this;
  
    let result;
    if (!arr) {
        result = context.fn();
    } else {
        result = context.fn(...arr);
    }
      
    delete context.fn
    return result;
}
```